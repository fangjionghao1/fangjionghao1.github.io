---
title: 定时器（待整理）
description: 简单定时器
date: 2023-02-24
slug: 工具
# image: Snipaste_2023-02-13_18-16-10.png
categories:
  - go
  - 工具开发
---

### 背景

系统中有一些定时任务。部署环境`windows2003r`,所以不能使用 `linux` 的 crontab 来做定时任务，另外就是编译成一个一个小工具，每次有新的定时任务就要做一个新的小工具。而且代码全封装，像是一个个 dll,如果有问题不好调试。
为此考虑制作一个定时任务调度的小系统。

### 思路

需要做的功能从底下到上层分别有
计时器:轮询计时任务列表，不断尝试拿出队头元素，检查是否到了 firetime，如果到了 firetime 执行相应的函数。
计时器离线功能：假如计时器始终在内存中，基本库都能实现这些功能。但是如果系统异常断电还要继续拉起未完成的定时任务，这时候就要考虑两个方向，一个是断线期间过期的任务怎么办，一个是怎么找到之前内存中的计时器。
所以要做持久。
持久的基本思路是：把计时器相关的内容放进数据库（入磁盘-可以不是数据库，文件一样可行）。计时器的相关内容包括，下一个执行时间和执行的函数，由于回调在内存中每次重启函数的内存位置都不好找所以换个思路就是用回调关键字来注册。熟悉微服务的朋友也许就感觉，这不是有点 etcd 的味道了。这样一来每次重启都能恢复计时器。
进一步既然要有回调函数，就要对回调函数进行管理
回调函数管理：包括回调的启停和注册注销
计时器的管理：单纯顺着的计时器并不好用，所以要加上

1. 找到上一个执行周期
2. 找下一个执行周期

所以持久的内容又要加上上一个执行计时器的时间。

到目前为止 计时器需要记录 关键字，下一个执行时间（或上一个（如果嫌麻烦可以两个都记录））

### 连载中。。。

##### 20230301 更新

发现计时器对于数据库有依赖，这样变成了数据库和定时器深度耦合，对于之后扩展定时任务不利，很容易造成循环依赖。
所以选择了一个做法就是内存计时器在计时的时候提供相关数据给关心的组件订阅，这个订阅动作在计时器开始的时候就已经准备好了。
比如数据库关心这部分的数据，就会拿走相应的结构，比如执行的计时器以及计时器的时间

> 关于这个设计有一点要提一下，最早是只提供 id 让数据库根据 id 自己玩，后面发现由于计时器的间隔不一样，同时开始的两个计时器最终的 firetime 会相差甚远。于是加上了执行时间，计时器只记录下一个启动时间。
> 但是这样设计就立刻暴露出两个问题。

- 保持这样的设计保证顺序，要加一个 broker 让其他关心的组件多消费。
- 不同组件关心的数据不同，broker 是否要加上处理的逻辑
  > 关于回调我还是选择了公共的回调池
- 风险是：数据竞争，加了锁也有两个回调同时执行的可能。把回调分配出去意味着回收要去定时堆里面找
- 收益是：方便做回调的管理

##### 20230310 更新

计时器的事情空闲时间又想到了一些问题。
为了解耦加上了一个管道去消费，解耦非常完美，关注的人去消费就好了。但是问题是如果出现错误应该用什么机制去处理。
计时器是顺序的，如果过去的处理影响了现在的处理，就一定会有一次定时任务夹在两次调用之间被持久层当成没有发生过从而产生多一次或者少一次的情况。
为了处理这个问题，我试着引入一种机制：增加一个重试队列，带着任务的 id 和触发时间，如果下一次触发时间晚于当前时间，被当做是过期的重试。过期重试不执行。
