[{"content":"背景 系统中有一些定时任务。部署环境windows2003r,所以不能使用 linux 的 crontab 来做定时任务，另外就是编译成一个一个小工具，每次有新的定时任务就要做一个新的小工具。而且代码全封装，像是一个个 dll,如果有问题不好调试。 为此考虑制作一个定时任务调度的小系统。\n思路 需要做的功能从底下到上层分别有\n最下层-内存计时器: 这个功能的核心，就是一个计时器，和传统概念里的定时器没有区别，设置开始时间，间隔时间，注册回调，让函数在开始时间经过指定间隔时间之后执行回调函数\n第二层-赋予数据持久能力：\n目的：加入服务器异常中断，定时任务就会被打乱。 因为内存只有系统启动的时间这个信息，定时任务重要的是开始时间，这影响了下一次执行时间 做法：持久内存中的任务，包括 任务的名称（关键字）：用于和回调绑定 任务的开始时间 下一次触发时间 间隔时间 是否重复（可选） 回调数据（可选）：为了赋予回调函数更强的能力，记录回调函数需要用到的参数，就像一次 rpc 调用一样，只不过这次发起方是系统，响应在未来，返回到现在。 超期日期（可选）：过了指定时间就废弃这个定时器，定时器扫描的时候跳过 也会删除相应的记录 参考用的表结构\n1 2 3 4 5 6 7 8 9 10 11 CREATE TABLE `timer_stores` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `fire_time` datetime(3) NOT NULL, `interval` varchar(15) NOT NULL, `key` varchar(30) DEFAULT NULL, `repeat` tinyint(1) DEFAULT NULL, `data` longtext, `belong_user` bigint(20) DEFAULT NULL, `expire` bigint(20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=86 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; 第三层 可以理解成应用层\n注册大量的回调函数去和关键字绑定，当需要某种功能的时候就可以根据关键字赋予定时器指定的功能 扩展： 设置启停的关键字，可以跳过某些定时器 这个是应用的基本结构，那么代码的逻辑就很清晰了，简单提几个状态描述一下后面直接上代码\n服务启动状态：这个状态要做的有 持久层获取定时器的数据信息 注册回调信息 启动内存定时器（一定要先注册回调才能启动内存定时器，但是内存定时器和持久谁先谁后无所谓） 定时器触发阶段，根据 ID 更新下一次触发时间 代码示例 持久层计时器 1 2 3 4 5 6 7 8 9 10 // TimerStore @Description: 计时器存储实体 type TimerStore struct { Id uint64 `gorm:\u0026#34;type:bigint(20) AUTO_INCREMENT;not null;primaryKey;column:id\u0026#34; json:\u0026#34;id,omitempty\u0026#34;` FireTime db.MpsTime `gorm:\u0026#34;column:fire_time;type:time\u0026#34; json:\u0026#34;fireTime\u0026#34;` Interval db.MpsDuration `gorm:\u0026#34;column:interval;type:varchar(30)\u0026#34; json:\u0026#34;interval,omitempty\u0026#34;` Key string `gorm:\u0026#34;column:key;type:varchar(15)\u0026#34; json:\u0026#34;key,omitempty\u0026#34;` Repeat bool `gorm:\u0026#34;column:repeat;type\u0026#34; json:\u0026#34;repeat,omitempty\u0026#34;` Data string `gorm:\u0026#34;column:data;type:varchar(255)\u0026#34; json:\u0026#34;data,omitempty\u0026#34;` BelongUser *int `gorm:\u0026#34;column:belong_user;type:bigint(20)\u0026#34; json:\u0026#34;belongUser,omitempty\u0026#34;` } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 // UpdateTimerInDb2NextFireTimeCallBack change timer fire time func UpdateTimerInDb2NextFireTimeCallBack(store TimerStore) func() { data, id, key, repeat, interval := store.Data, store.Id, store.Key, store.Repeat, store.Interval // 为了让回调需要的变量都限制在该函数内 return func() { tx := db.DB.Model(\u0026amp;TimerStore{}).Where(\u0026#34;id = ?\u0026#34;, id) defer func() { if !repeat \u0026amp;\u0026amp; id != 0 { // 表示在数据库中有数据 tx.Delete(\u0026amp;TimerStore{}) //如果不重复就删除相关的定时器 } else if id != 0 { // repeat if err := tx.UpdateColumn(\u0026#34;fire_time\u0026#34;, time.Now().Add(time.Duration(interval))).Error; err != nil { logger.Log.Errorf(\u0026#34;update fire time in db error %v\u0026#34;, err) } } }() if f := callBack.GetFunc(key); f != nil { // 获取回调 如果没有就不执行 如果开关没有开启则获得一个假回调 if err := callBack.GetFunc(key)(data); err != nil { logger.Log.Errorf(\u0026#34;timer call back func error %v\u0026#34;, err) return } } } } // AddTimer 添加计时器 处理数据库数据和堆数据 func AddTimer(t ...TimerStore) error { // 对加入的计时器进行判定 业务计时器和恢复计时器分开处理 for idx := range t { timerStore := t[idx] // 防止下面使用定时器中的指针 duration := time.Duration(timerStore.Interval) if duration == 0 \u0026amp;\u0026amp; timerStore.Repeat { return errors.New(\u0026#34;no repeat task need interval\u0026#34;) } if timerStore.FireTime.IsZero() { // 如果开始时间为空则对开始时间赋予一个初值 timerStore.FireTime.Time = time.Now().Add(duration) } switch true { case t[idx].Id != 0: // 表示在数据库之中 if timerStore.FireTime.Before(time.Now()) { // 处理时间问题 if duration != 0 { timerStore.FireTime.Time = time.Now().Add(timerStore.FireTime.Sub(time.Now()) % duration).Add(duration) // 更新数据库 } else { timerStore.FireTime.Time = time.Now() } if err := db.DB.Model(\u0026amp;timerStore).Where(\u0026#34;id = ?\u0026#34;, timerStore.Id).Update(\u0026#34;fire_time\u0026#34;, timerStore.FireTime).Error; err != nil { return err } } // 不早于当前不做相应处理 default: // 表示不在数据库之中 if err := db.DB.Model(\u0026amp;timerStore).Create(\u0026amp;timerStore).Error; err != nil { // 没在数据库中就添加数据库获取id 不管时间短不短 return err } } timerHeap.H.AddTimers(timerHeap.Timer{ID: timerStore.Id, FireTime: timerStore.FireTime.Time, Repeat: timerStore.Repeat, Interval: duration, Tag: timerStore.Key}, UpdateTimerInDb2NextFireTimeCallBack(timerStore)) } return nil } // InitTh 初始化定时堆 func InitTh(d time.Duration) { var res []TimerStore err := db.DB.Model(\u0026amp;TimerStore{}).Find(\u0026amp;res).Error if err != nil { logger.Log.Errorf(\u0026#34;rerieve timer store error %v\u0026#34;, err) } if err = AddTimer(res...); err != nil { logger.Log.Fatal(err) } timerHeap.H.StartTicks(d) } // RemoveTimerStore 移除掉计时器 为了方式只删除内存或者数据库某一边的计时器 建议使用这个方式删除 func RemoveTimerStore(id uint64) error { err := db.DB.Model(\u0026amp;TimerStore{}).Where(\u0026#34;id = ?\u0026#34;, id).Delete(TimerStore{}).Error if err != nil { return err } timerHeap.H.Remove(id) return nil } 内存计时器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 package timerHeap import ( \u0026#34;container/heap\u0026#34; \u0026#34;mps/common/db\u0026#34; \u0026#34;mps/logger\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var H = NewTimerHeap() const ( MinTimerInterval = 10 * time.Millisecond // 循环定时器的最小时间间隔 ) const ( defaultMode uint8 = iota goroutineMode ) func (th *TimerHeap) ListTimer() (res []Timer) { th.lock.Lock() defer th.lock.Unlock() for _, timer := range th.timers { res = append(res, *timer) } return res } // CallbackFunc 定时器回调函数的类型定义 type CallbackFunc func() // Timer 定时器对象 type Timer struct { ID uint64 // 外部Id (唯一, 用于更新和移除指定的定时器) FireTime time.Time // 触发时间 Interval time.Duration // 时间间隔（用于循环定时器） Tag string // 用于携带必要的外部信息，扩展使用，仅作为信息属性 callback CallbackFunc // 回调函数 Repeat bool // 是否循环 cancelled bool // 是否已经取消 addSeq uint // 序号,自增 } // Cancel 取消一个定时器，这个定时器将不会被触发 func (t *Timer) Cancel() { t.cancelled = true } // IsActive 判断定时器是否已经取消 func (t *Timer) IsActive() bool { return !t.cancelled } type TimeFmt struct { T db.MpsTime Id uint64 } // TimerHeap 使用一个heap管理所有的定时器 type TimerHeap struct { timers []*Timer hooks map[string][]func(timer *Timer) // hooks // @Description: 一组回调 对每一个pop出来的计时器进行一些操作 openHook bool // openHook // @Description: 钩子开关 nextAddSeq uint poolSize int expire time.Duration invokeMode uint8 stop bool lock sync.Mutex } // Len 堆排序接口实现 func (th *TimerHeap) Len() int { return len(th.timers) } func (th *TimerHeap) Less(i, j int) bool { if th.timers[i].FireTime.Before(th.timers[j].FireTime) { return true } if th.timers[i].FireTime.After(th.timers[j].FireTime) { return false } // 两个timer的触发时间一致时，按其入堆的顺序 return th.timers[i].ID \u0026lt; th.timers[j].ID } func (th *TimerHeap) Swap(i, j int) { th.timers[i], th.timers[j] = th.timers[j], th.timers[i] } func (th *TimerHeap) Push(x interface{}) { th.timers = append(th.timers, x.(*Timer)) } func (th *TimerHeap) Pop() (ret interface{}) { l := len(th.timers) th.timers, ret = th.timers[:l-1], th.timers[l-1] return } // Update 修改指定的id的Timer的触发时间 func (th *TimerHeap) Update(id uint64, nt time.Time) { th.lock.Lock() defer th.lock.Unlock() for k, v := range th.timers { if v.ID == id { v.FireTime = nt heap.Fix(th, k) break } } } // Remove 删除指定的id的Timer // tips: 无绑定index filed, 在for循环中不能使用heap.Remove()来删除指定项；因为heap.Remove的过程中有一次移动至末尾，for可能再次匹配到 func (th *TimerHeap) Remove(id uint64) int { th.lock.Lock() defer th.lock.Unlock() n := 0 for k, v := range th.timers { if v.ID == id { th.timers = append(th.timers[:k], th.timers[k+1:]...) n++ } } heap.Init(th) return n } // Peek 查看某个指定id的Timer func (th *TimerHeap) Peek(id uint64) *Timer { for _, v := range th.timers { if v.ID == id { return v } } return nil } // GetTimersWithTag 读取指定tag的timers，不包含cancelled为true的timer func (th *TimerHeap) GetTimersWithTag(tag string) []*Timer { var ret []*Timer for _, v := range th.timers { if v.Tag == tag \u0026amp;\u0026amp; v.cancelled == false { ret = append(ret, v) } } return ret } // NewTimerHeap 新建一个小顶堆定时器 func NewTimerHeap() *TimerHeap { var timerHeap TimerHeap heap.Init(\u0026amp;timerHeap) timerHeap.nextAddSeq = 1 timerHeap.invokeMode = defaultMode return \u0026amp;timerHeap } // NewTimerHeapWithGoroutine 新建一个小顶堆定时器, 每个callback独立使用协程运行 func NewTimerHeapWithGoroutine() *TimerHeap { var timerHeap TimerHeap heap.Init(\u0026amp;timerHeap) timerHeap.nextAddSeq = 1 timerHeap.invokeMode = goroutineMode return \u0026amp;timerHeap } func (th *TimerHeap) AddTimers(timer Timer, callbackFunc CallbackFunc) *Timer { th.lock.Lock() if timer.Repeat { if timer.Interval \u0026lt; MinTimerInterval { timer.Interval = MinTimerInterval } } if timer.FireTime.IsZero() { timer.FireTime = time.Now().Add(timer.Interval) } timer.callback = callbackFunc timer.addSeq = th.nextAddSeq th.nextAddSeq += 1 heap.Push(th, \u0026amp;timer) th.lock.Unlock() return \u0026amp;timer } // Tick 对定时器模块进行一次Tick func (th *TimerHeap) Tick() { now := time.Now() th.lock.Lock() defer th.lock.Unlock() for { // 没有任何定时器，返回 if th.Len() \u0026lt;= 0 { break } //堆顶,没有到时间的定时器，返回 if th.timers[0].FireTime.After(now) { break } // 从heap中拿出堆顶 t := heap.Pop(th).(*Timer) // 忽略已经取消的定时器 if t.cancelled { continue } // 非周期任务，则下一次迭代中Pop() if !t.Repeat { t.cancelled = true } // 同步协程执行回调 if th.invokeMode == defaultMode { runCallback(t.ID, t.callback) } // 异步协程执行回调 if th.invokeMode == goroutineMode { go func() { runCallback(t.ID, t.callback) }() } // 如果是循环timer就把Timer重新放回heap中 if t.Repeat { t.FireTime = t.FireTime.Add(t.Interval) if !t.FireTime.After(now) { t.FireTime = now.Add(t.Interval) } t.addSeq = th.nextAddSeq th.nextAddSeq += 1 heap.Push(th, t) } } } //func runHook(timer *Timer, fs ...func(timer *Timer)) error { //\tfor _, f := range fs { //\tf(timer) //\t} //} // AddRepeatTimerWithFixedMoment 设置一个定时触发的回调，每日的固定时刻(时分秒，UTC时间)执行，并调用callback函数 //func (th *TimerHeap) AddRepeatTimerWithFixedMoment(h, m, s int, callback CallbackFunc, id uint64, tag string) *Timer { //\tnow := time.Now() //\tnext := time.Date(now.Year(), now.Month(), now.Day(), h, m, s, 0, time.UTC) //\tvar wait time.Duration //\tif next.Sub(now) \u0026gt; 0 { //\twait = next.Sub(now) //\t} else { //\ttomorrow := time.Date(now.Add(24*time.Hour).Year(), now.Add(24*time.Hour).Month(), now.Add(24*time.Hour).Day(), h, m, s, 0, time.UTC) //\twait = tomorrow.Sub(now) //\t} //\tt := \u0026amp;Timer{ //\tID: id, //\tFireTime: time.Now().Add(wait), //\tInterval: 24 * time.Hour, //\tTag: tag, //\tcallback: callback, //\tRepeat: true, //\t} //\tth.lock.Lock() //\tt.addSeq = th.nextAddSeq //\tth.nextAddSeq += 1 //\theap.Push(th, t) //\tth.lock.Unlock() //\treturn t //} // AddRepeatTimerNextClock 设置一个定时触发的回调，下一个整点时间开始执行，每间隔d时间重复触发，并调用callback函数 //func (th *TimerHeap) AddRepeatTimerNextClock(d time.Duration, callback CallbackFunc, id uint64, tag string) *Timer { //\tt1, _ := time.ParseInLocation(\u0026#34;2006-01-02 15:04:05\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15:00:00\u0026#34;), time.UTC) //\twait := time.Duration(t1.Truncate(1*time.Hour).Unix() + 3600 - time.Now().Unix()) //\tt := \u0026amp;Timer{ //\tID: id, //\tFireTime: time.Now().Add(wait), //\tInterval: d, //\tTag: tag, //\tcallback: callback, //\tRepeat: true, //\t} //\tth.lock.Lock() //\tt.addSeq = th.nextAddSeq //\tth.nextAddSeq += 1 //\theap.Push(th, t) //\tth.lock.Unlock() //\treturn t //} // StartTicks 创建一个goroutine对定时器模块进行定时的Tick func (th *TimerHeap) StartTicks(tickInterval time.Duration) { //th.stop = false //go func() { //\tfor th.stop { // //\t} //}() go th.selfTickRoutine(tickInterval) } func (th *TimerHeap) Stop() { th.stop = true } func (th *TimerHeap) selfTickRoutine(tickInterval time.Duration) { if tickInterval \u0026lt; MinTimerInterval { tickInterval = MinTimerInterval } for { if th.stop { return } time.Sleep(tickInterval) th.Tick() } } // 运行定时器的回调函数，并捕获panic，将panic转化为错误输出 func runCallback(id uint64, callback CallbackFunc) { defer func() { err := recover() if err != nil { logger.Log.Errorf(\u0026#34;Callback %v panic: %v\\n\u0026#34;, id, err) var buf [4096]byte n := runtime.Stack(buf[:], false) logger.Log.Errorf(\u0026#34;Callback exits from panic: %s\\n\u0026#34;, string(buf[:n])) } }() callback() } ","date":"2023-05-25T10:29:08+08:00","permalink":"https://fangjionghao1.github.io/p/%E6%8C%81%E4%B9%85%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BD%92%E6%A1%A3%E6%95%B4%E7%90%86%E7%89%88/","title":"持久定时器（归档整理版）"},{"content":"兜兜转转还是会回到起点，有什么不一样了，来时明白，走时更明白。\n午休看到音乐的 aigc ，用法很简单，只需要音乐风格就能得到一个不错的 beat,随便听了一首 trap,质量真的不错，效果器调教的很适合标签，甚至做了侧链压缩 想起来之前和学长讨论的，古典和电子的问题，只不过当时主体是初音今天主体换成了 ai 学长千古哈哈哈哈哈 0522\n","date":"2023-05-23T05:40:19.432Z","permalink":"https://fangjionghao1.github.io/p/%E9%9A%8F%E6%89%8B%E8%AE%B0/","title":"随手记"},{"content":"木漏れ日 罗马音 komorebi 日 hi 发生连浊变成 bi 中高型 东京方言 ko 高 more 低高 bi 高 ko 木 more 漏^も れ 洩露，穿過 是漏^も れる moreru 的连用型 morata 漏^も れ是过去式\n","date":"2023-05-22T11:01:41+08:00","permalink":"https://fangjionghao1.github.io/p/%E6%97%A5%E8%AF%AD%E5%8D%95%E8%AF%8D/","title":"日语单词"},{"content":"背景 从表格导入一些用户数据 顺手开发了这些工具。 本文的前提是了解了基本函数的使用方法，因为有中文文档就不再赘述 excelize 文档地址\n适用场景 任何二维表格都可以用这种方式做统计\n思路简述 找到一个表格的边界，在表格范围内的内容遍历并根据参数按行列进行读取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 var rwM sync.RWMutex // 读写锁 var chMap = map[string]int{ \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2, \u0026#34;C\u0026#34;: 3, \u0026#34;D\u0026#34;: 4, \u0026#34;E\u0026#34;: 5, \u0026#34;F\u0026#34;: 6, \u0026#34;G\u0026#34;: 7, \u0026#34;H\u0026#34;: 8, \u0026#34;I\u0026#34;: 9, \u0026#34;J\u0026#34;: 10, \u0026#34;K\u0026#34;: 11, \u0026#34;L\u0026#34;: 12, \u0026#34;M\u0026#34;: 13, \u0026#34;N\u0026#34;: 14, \u0026#34;O\u0026#34;: 15, \u0026#34;P\u0026#34;: 16, \u0026#34;Q\u0026#34;: 17, \u0026#34;R\u0026#34;: 18, \u0026#34;S\u0026#34;: 19, \u0026#34;T\u0026#34;: 20, \u0026#34;U\u0026#34;: 21, \u0026#34;V\u0026#34;: 22, \u0026#34;W\u0026#34;: 23, \u0026#34;X\u0026#34;: 24, \u0026#34;Y\u0026#34;: 25, \u0026#34;Z\u0026#34;: 26, }// 枚举 var chArr = charArr{ \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;J\u0026#34;, \u0026#34;K\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;P\u0026#34;, \u0026#34;Q\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;T\u0026#34;, \u0026#34;U\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;W\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;Z\u0026#34;, } func (c *charArr) Translate(str string) Point { strRunes := []rune(str) colArr := make([]rune, 0) rowArr := make([]rune, 0) for _, strRune := range strRunes { switch strRune \u0026gt; 64 { case false: rowArr = append(rowArr, strRune) case true: colArr = append(colArr, strRune) } } var col int // 为了方便限制在26*26*26 switch len(colArr) { case 3: col = chMap[string(colArr[0])]*26*26 + chMap[string(colArr[1])]*26 + chMap[string(colArr[2])] case 2: col = chMap[string(colArr[0])]*26 + chMap[string(colArr[1])] case 1: col = chMap[string(colArr[0])] } var rowStr string for _, r := range rowArr { rowStr += string(r) } atoi, err := strconv.Atoi(rowStr) if err != nil { return Point{} } return Point{Col: col, Row: atoi} } type Point struct { Row int Col int } func (p *Point) NextCol() { p.Col += 1 } func (p *Point) NextRow() { p.Row += 1 } func (p *Point) trans() string { return chArr.GetAxis(*p) } func GetPoint(s string) Point { return chArr.Translate(s) } type ReadWay int const ( Col = ReadWay(1) // 按列聚合 Row = ReadWay(2) // 按行聚合 ) type ReadParam struct { Point Point Way ReadWay FileName string Sheet string EndPoint Point } func OpenFile(fileName string) (*excelize.File, error) { file, err := excelize.OpenFile(fileName) if err != nil { logger.Log.Errorf(\u0026#34;open excel file error %v\u0026#34;, err) return nil, err } return file, err } // ReadListFromPoint /* 【Description】: 从一个点出发 在end point 之间的表格做出统计 */ func ReadListFromPoint(p ReadParam) (map[string][]string, error) { file, err := OpenFile(p.FileName) if err != nil { return nil, err } defer func() { file.Close() }() m := make(map[string][]string) switch p.Way { case Col: // 按列聚合 startCol := p.Point.Col for p.Point.Row \u0026lt; p.EndPoint.Row { p.Point.NextRow() trans := p.Point.trans() idx, err := file.GetCellValue(p.Sheet, trans) if err != nil { return nil, err } for p.Point.Col \u0026lt; p.EndPoint.Col { p.Point.NextCol() val, _ := file.GetCellValue(p.Sheet, p.Point.trans()) m[idx] = append(m[idx], val) } p.Point.Col = startCol } case Row: // 按行聚合 startRow := p.Point.Row for p.Point.Col \u0026lt; p.EndPoint.Col { p.Point.NextCol() trans := p.Point.trans() idx, err := file.GetCellValue(p.Sheet, trans) if err != nil { return nil, err } for p.Point.Row \u0026lt; p.EndPoint.Row { p.Point.NextRow() val, _ := file.GetCellValue(p.Sheet, p.Point.trans()) m[idx] = append(m[idx], val) } p.Point.Row = startRow } } return m, nil } 比较坑的地方是用官方的按行读取读行标题的时候会导致之前读取的数据被回收，也就是 map 中的数据被清空。 建议是深度拷贝再进行按行列读取\n","date":"2023-02-24T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E5%B7%A5%E5%85%B7/","title":"excelize 库简介"},{"content":"连载中。。。欢迎补充 GO 篇 go 是强类型的语言，这意味着，变量要被指定，基本类型变量一诞生就带上类型，带上类型意味着占有空间，很自然能想到，基本类型的空值是默认有值的，比如 int 的空为 0 ，string 为\u0026quot;\u0026quot;。所以在序列化的时候这部分内容如果想要一个 null 值需要给结构定义指针。 实现接口的时候如果是指针接收者，特别是实现工具自带的接口，比如 marshal，要使用引用。 json 序列化的时候要声明一个临时类型，否则会因为自身的反复调用而 stack overflow 1 2 3 4 5 6 7 8 9 10 func (g *Group) MarshalJSON() ([]byte, error) { type tmp Group return json.Marshal(\u0026amp;struct { *tmp CreateTimeStr string `json:\u0026#34;create_time\u0026#34;` }{ tmp: (*tmp)(g), CreateTimeStr: g.CreatTime.Format(consts.TLayout.Date), }) } go 的时间类型默认格式是 YYYY-MM-DDTHH:MM:SSZ+0800,零时间是 0001-01-01 00：00 +0000 我的做法是年为 1 的时候判空，不能直接使用。 time 类型直接 string() 接口转出时间的时候，年月日都是单位的比如 3 月就是输出 3，但是一般要转回时间的时候就需要转换成 03,我的做法是静态的对应表，放在 util 里面需要的时候再用。 http 篇 前端数据不可信，不做修改的时候以后端数据为准，唯一值得参考的就是提供的身份信息，包括但不仅限于 id,token。做修改时以前端数据为准。 由于前后端要交换数据，其实选择 string 作为交换的格式挺有风险。举个例子就是时间选用 string 类型的时候后果是每次交互两边都要进行 前端是没有办法生成一个文件的。原因是前端能够操作的行为都是基于浏览器的，浏览器没有深入到操作系统的权限，除非是加一些黑科技，才能够到底层。这也就能理解为什么前端不能操作直接操作内存，也就不能进行文件操作，除非是用户授权，比如在multipartform当中操作。 Fiber 篇 fiber 注册的 handler 是有前后顺序分别的。原因是他在给 app 设置 handler 的时候底层实现是一个 slice。前后调用有区别就意味着不管是路由谁捕捉到，还是过滤器的先后都是有关系的。 staic 提供了很好的静态资源服务，但是要对静态资源做一些处理就很麻烦。我的做法是在 config next 字段加入一些回调能过抓得到 ctx 传下来的 token。对于一些用户相关的资源可以这么做但是不建议。 中间件文件系统暂时没看懂是怎么用的 queryParse这个接口能够直接将 url 上的参数用逗号分隔符解析到 string 数组当中，但是如果不传参数就会得到一个长度为 1 第一位是空字符的参数 另外这个函数的实现原理是反射，所以他只会根据反射获取结构名称，json 标签不起作用，要客制化的需求又想使用这个功能就从反射这块下功夫。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func TestQueryParse(t *testing.T) { app := fiber.New() app.Get(\u0026#34;/\u0026#34;, func(ctx *fiber.Ctx) error { var res struct { Id int `json:\u0026#34;id\u0026#34;` NameAA string `json:\u0026#34;name_aA\u0026#34;` NameaA string `json:\u0026#34;namea_a\u0026#34;` } err := ctx.QueryParser(\u0026amp;res) if err != nil { return ctx.SendStatus(http.StatusInternalServerError) } t.Log(res) return ctx.SendStatus(http.StatusOK) }) req := httptest.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/?id=23\u0026amp;nameAA=nameAA\u0026amp;namea_a=namea_a\u0026#34;, nil) resp, err := app.Test(req, -1) assert.NoError(t, err) all, err := io.ReadAll(resp.Body) assert.NoError(t, err) t.Log(string(all)) } /* === RUN TestQueryParse main_test.go:49: {23 nameAA } main_test.go:57: OK --- PASS: TestQueryParse (0.00s) */ gorm 篇 综述：gorm 的坑还是非常多的，一不小心就会用错，如果现在开放出来的函数不能实现需求的话建议还是用raw()\n查询篇 where()方法和 or 方法一起使用的时候，以 or 为分界拼接 sql。简单来说就是 or 之后是一个新的子句。 first 方法在查找不到记录的时候会返回一个 notfound 错误，需要做处理，但是 find 不会。 在版本 1.32.6 版本中，存在一个问题，如果数据库中存在空值，并将数据查询结果写入切片的时候，表项的空（NULL）值会使用上一条数据的值。 创建篇 在给类型写 scanner valuer 接口的时候 valuer 的接收者不能是指针接收者，否则无法触发相关行为 声明篇 默认的表名，字段名是驼峰改蛇形 model 单数会自动加复数 s table 不会触发 hook 在 gorm.DB 的 model 是使用的时候设置的，如果还想给 hook 传递信息只有通过 set，但是考虑到并发的时候，并不建议给单例 set，可以 getinstance 做一次克隆在给 db set 一些参考的参数。而且 get 需要通过制定的关键字获取，这就意味着要对参数做约定。业务一多，约定的关键字就成了关键字表，不统一管理前后不对照会 panic viper（配置篇） moby 篇（docker） reexec 篇 moby 下一个很方便的工具包，基本上是零依赖，可以直接拷贝下来使用。 moby 的基本原理有时间再研究，讲一下注意点。 他会在 arg[0]里设置任务的 pid 让主程序作为子程序的守护，并管理子程序的生命周期。如果想要做守护就是拿着 run()返回的 pid 去反复重启任务。\n源码阅读 cmd_windows.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package reexec // import \u0026#34;github.com/docker/docker/pkg/reexec\u0026#34; import ( \u0026#34;os/exec\u0026#34; ) // Self returns the path to the current process\u0026#39;s binary. // Uses os.Args[0]. func Self() string { return naiveSelf() } // Command returns *exec.Cmd which has Path as current binary. // For example if current binary is \u0026#34;docker.exe\u0026#34; at \u0026#34;C:\\\u0026#34;, then cmd.Path will // be set to \u0026#34;C:\\docker.exe\u0026#34;. func Command(args ...string) *exec.Cmd { return \u0026amp;exec.Cmd{ Path: Self(), Args: args, } } reexec.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // Package reexec facilitates the busybox style reexec of the docker binary that // we require because of the forking limitations of using Go. Handlers can be // registered with a name and the argv 0 of the exec of the binary will be used // to find and execute custom init paths. package reexec // import \u0026#34;github.com/docker/docker/pkg/reexec\u0026#34; import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;path/filepath\u0026#34; ) var registeredInitializers = make(map[string]func()) // Register adds an initialization func under the specified name // 不作过多解释 用map来注册一个非重复的进程初始化回调，名字冲突时panic func Register(name string, initializer func()) { if _, exists := registeredInitializers[name]; exists { panic(fmt.Sprintf(\u0026#34;reexec func already registered under name %q\u0026#34;, name)) } registeredInitializers[name] = initializer } // Init is called as the first part of the exec process and returns true if an // initialization function was called. func Init() bool { initializer, exists := registeredInitializers[os.Args[0]] if exists { initializer() return true } return false } func naiveSelf() string { name := os.Args[0] if filepath.Base(name) == name { if lp, err := exec.LookPath(name); err == nil { return lp } } // handle conversion of relative paths to absolute if absName, err := filepath.Abs(name); err == nil { return absName } // if we couldn\u0026#39;t get absolute name, return original // (NOTE: Go only errors on Abs() if os.Getwd fails) return name } 工具使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 var args []string args = append(append(append(args, \u0026#34;xxx\u0026#34;), strconv.Itoa(os.Getpid())), os.Args[1:]...) reexec.Register(\u0026#34;xxx\u0026#34;, App) reexec.Register(\u0026#34;xxxxx\u0026#34;, AppSdk) if reexec.Init() { logger.Log.Error(\u0026#34;init mps process error\u0026#34;) os.Exit(0) } logger.Log.Infof(\u0026#34;[%v] process daemon process start ,os args [%v] -----------startTime--[ %v ]\u0026#34;, os.Getpid(), os.Args, time.Now().String()) go func() { var stdErr bytes.Buffer for { select { case \u0026lt;-OverChan: return default: cmd := reexec.Command(\u0026#34;xxxxx\u0026#34;, strconv.Itoa(os.Getpid())) cmd.Stderr = \u0026amp;stdErr err := cmd.Run() if err != nil { logger.Log.Errorf(\u0026#34;command error [%v]\\n\u0026#34;, stdErr.String()) } time.Sleep(restartDuration) } } }() var stdErr bytes.Buffer for { select { case \u0026lt;-OverChan: return default: cmd := reexec.Command(\u0026#34;xxx\u0026#34;, strconv.Itoa(os.Getpid())) cmd.Stderr = \u0026amp;stdErr err := cmd.Run() if err != nil { logger.Log.Errorf(\u0026#34;command error [%v]\\n\u0026#34;, stdErr.String()) } time.Sleep(restartDuration) } } ","date":"2023-02-24T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/","title":"web服务踩的坑"},{"content":"背景 在开发 http 服务的时候日常要修修补补，免不了要暂停线上的服务然后发通告更新服务，之后进行非常紧张的更新部署，并在小范围用特殊账号测试做个基本的线上回归。 加入部署出现问题，这时候就要继续发通告延期，久了更新维护更紧张。 为了解决维护的麻烦，选择使用热部署的方式。这样就可以让用户透明的访问，而后台也能正常进行维护。\n##概述\n###什么是热部署\n就是在应用正在运行的时候升级软件，却不需要重新启动应用。 但是对于不同类型的语言来说，热部署的意义不同。 对于 解释型语言，或许就意味着一次更新代码。因为解释型语言只需要从内存中获取相关文件，所以很经常前端代码不需要暂停服务直接替换文件就可以使用。 而对于 编译型语言 基本上就意味着两个不同的可执行文件 基于这两个基本观点，解释型语言和编译型语言的热部署方案就截然不同。\n比如常用的服务器开发语言，java,常见的热部署方案参考 tomcat，devtool 的热重启，\n因为要编译然后跑在 jvm 上，直接简单点认定成编译型语言吧，关于这个点不是今天讨论的重点。有感兴趣的朋友可以在评论区讨论。 今天不讨论解释型语言的热部署方式没因为根本没这个概念，像 php 的热部署就是换一个文件，每次脚本都是去读文件根本不存在之前和之后的区别。\n拿 devtool 来讲，他的做法是分别加载修改的类和不修改的类，再往下是监听文件，实现毫秒级的编译重启。这种做法描述起来就是，我确实断线过，但是太短了（毫秒）察觉不到，用热重启的方式来实现热部署。tomcat 的思路也是差不多就不在赘述。\n另一个热部署的方式就是热替换。 热替换的思路很多，\n游戏服务器的思路是把业务 package 编译成 plugin，动态加载和替换，再通过 plugin.Lookup 来查找和替换函数。 缺点是： 受 Go Plugin 本身的限制，如第三方依赖需要一致、不能引用插件 package、插件内数据类型共享、插件无法释放、调试相对困难、跨平台问题等 对业务代码侵入式较强，包括 plugin main package 限制、Lookup 调用方式、发布流程等 我的做法是代理交接服务。简单来说就是编译了两个服务，我先让两个服务并存，再让流量转到新的服务上从而接管过去的服务。听起来很像代理，所以我个人的做法是用代理的方式。 ##目前最优的解决方案\n使用代理服务，当用户访问的时候实际上是访问代理服务，代理服务为服务器转发流量到当前最新的服务器。 服务器遵守规则： 实现注册服务,服务启动时向代理服务注册自身信息，包括但不仅限于版本号 实现保活服务，代理服务将会访问服务器的保活接口，确保服务器的存活状态。 服务要求识别特殊的返回结构，这是约定好的通信格式，包括一些特定的 code，为了避免污染 proxy 的纯粹性，尽量不要让这种通信格式里面带有一些业务的东西，包括 token 也尽量不要再 proxy 里面有接口。这样的约定一定是基于服务的抽象，比如通知服务中断，服务重启，服务关闭之类的，就目前而言只需要有一个服务重启的信号和一个服务关闭信号就好，而和业务产生关系的只有服务重启。 对于上述的规则做个总结就是，服务器需要一个保活服务、接收服务重启通知的服务和 rpc 的关闭，具体实现的方式其实因人而异，可以选择 http 的就是写一个接口，或者一个 grpc 服务热部署的难点： 本身服务热重启其实做到代理以后完成了一大半。因为服务器内部并不会共享一些资源，包括配置和内存都是独立分配和独立使用。一个未完成的接口调用也由原先的协程来完成，完成后这个协程就再也无法接收到代理信息也就自然可以用机制想办法关闭，proxy 再自然回收那部分内存。问题就在于一个页面往往不仅仅只包含着一个接口调用。 还有要明确的一点就是，服务热部署对于编译型语言编写的服务器，文件层次上一定是两个文件，显而易见他们是不同的执行文件，这也意味着内部端口在热部署的时候至少是占有复数个的 试想这么一种情况，假如说我在加载一个界面的时候进行了热部署，这个时候加载了两种条目，分别来自v1 和 v2 程序就被撕裂了。 如果是 tcp 的服务其实可以考虑，当新的代理连接接入时根据标记判断当前连接的使用状态在完成业务也就是和客户端断开连接的时候主动断开与代理的连接，重新建立连接————长连接总是可以在连接状态上做文章。 http 的想法就不那么自然一点。新的服务被拉起的时候，如果只有一个服务，也就是服务被拉起之前没有任何服务自然是最简单的情况，不需要任何操作直接接受代理服务器的服务就好了。\n而另一种情况就没这么愉快。服务被拉起的时候新旧服务要短暂的并行一段时间，之所以没有直接关闭是可能有正在走旧连接的业务，直接关闭会让一部分请求突然丢失。对应着 tcp 的情况就是检查连接上是否有正在运行的业务。而做这个检查的方式就是在代理服务器记录请求的时间。再具体下去选择的数据结构来承载这个行为，选择的是 map\n可以永远相信带读写锁的 map 来实现业务，而需要更快的检索速度的时候再考虑是否换其他更高效的结构，以及更换结构带来的问题，使用结构带来的复杂度\n用 map 记录服务请求的时间戳超过 300s 没有进行请求的时候可以安心把服务切断切换，转而使用新的连接。使用新连接之后要做相应的扫尾工作，包括删除代理中的注册信息，删除时间戳。同时标记好下一次保活心跳来的时候给应答一个服务重启信号，这个是说给旧服务听的，旧服务再说给外部服务。让外部服务来做一次大更新，包括刷新 token 和个人信息。proxy 做完这些要做一次关闭服务的调用，正式告别旧服务，意味着更新完成。\n本篇主要是方法论，具体实现会在后续更新。\n","date":"2023-02-20T00:00:00Z","image":"https://fangjionghao1.github.io/p/funjohnhow/_hu43d2d81e576066052a6f5913b37b6310_577754_121c9ab0b3dadf7b4b19129b45439ea9.png","permalink":"https://fangjionghao1.github.io/p/funjohnhow/","title":"热部署方案小记"},{"content":"背景 有次朋友跟我聊起恐怖电影，自诩电影爱好者聊起这个领域的东西的时候张口啊闭口嗯，半天支吾不出个所以然来，所以在个人博客开了这个分类，想要整理一些平常感兴趣的领域的概念。\n分类说明 语料表示聊天需要用到的概念或者想法，提前写在博客里面。 电影这个分类就很明朗了，不再说明\n正文 概念 说明 麦格芬（MacGuffin）手法 ——基本释义——① 指某个推动戏剧发展的契机、情节，或角色们拼命追逐的可能不存在的东西，观众也可能不关心，它出现目的在于引导观众沉浸于电影体验 ② 开端是[三十九级台阶]，通过阿尔弗雷德·希区柯克在其后来电影中的使用流行起来。* 举例：“你在做什么？”“我在找麦格芬”“麦格芬是什么”“捕猎北方冰原上狮子的最好武器”“可是北方冰原没有狮子”“那也没有麦格芬” 。麦格芬，按照希区柯克的定义是“悬疑电影中角色们必须要拼命追逐，可观众却可以毫不关心的东西”。但是，在本片中，当要叙述的故事，写实到必须要把破坏份子的意图和目标交代清楚的时候，麦格芬失效了。失效的最直接的后果，就是观众对故事真实性要求大大提高了。因为他们知道了角色动机和事件的来龙去脉，他们也就知道了，相对应的合理逻辑行为关系应该是什么。而这对悬疑片导演来说，是十分可怕的。因为你的剧情设计任何逻辑上的缺陷都很容易就被放大！比如在本片中，当观众了解到破坏份子的政治立场和凶残本性之后，那么影片后半段，男主角只是被打昏，却没有被杀死这个情节就变得难以令人信服。相反，在一个高度风格化、喜剧轻松，且麦格芬有效的故事背景下（比如西北偏北），这些问题就很可能不成为问题。因为观众不清楚，也根本不关注坏人们的行为逻辑。 炸弹理论 如果有三个人在玩儿扑克牌，在牌桌下有一颗炸弹。如果你只是讲述三个人玩牌，然后突然爆炸了，那么故事就毫无悬念。但如果你事先将炸弹的存在告诉读者，然后再展示三个不知情的人玩儿牌，那么观众就会时时刻刻关心炸弹什么时候爆炸。这就是炸弹理论。简单来说，这里理论就是讲，需要在故事开始前，向观众展示一个危机，观众知道，但剧情中的人物并不知道。而这个危机似乎随时都可能爆发。这样，便形成了一个悬念和故事张力。这里的炸弹可以使非常抽象的东西，隐秘的关系，不稳定的因素，脆弱的感情，任何对于观众而言已知的不稳定的因素都可以是炸弹 叙诡（叙述性诡计） 是流行于推理小说写作的一种写作手法。通过运用语言上的歧义，或者偷换文字结构的方式，以达到误导读者的目的。 随手记 虽然明知道说话的时候不看着对方不太礼貌，也给自己找了借口是一直看着比较有攻击性，但是说实话别人在讲到一半突然插嘴属实有点不合适 ","date":"2023-02-20T00:00:00Z","image":"https://fangjionghao1.github.io/p/%E8%AF%AD%E6%96%99%E6%95%B4%E7%90%86/2_hue29632e6cc72d9fc68bcf057123f6a80_4122094_120x120_fill_q75_box_smart1.jpg","permalink":"https://fangjionghao1.github.io/p/%E8%AF%AD%E6%96%99%E6%95%B4%E7%90%86/","title":"语料整理"},{"content":"环境准备 系统环境：Windows 10 专业版\n需求环境：git,hugo,go(1.16 or ⬆),scoop(window 包管理器 不熟悉的同学可以理解成和 npm 差不多的东西)\nhugo 安装文档\nscoop 安装教程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 安装 Hugo brew install hugo(mac 👍) scoop install hugo(win 👍) # 创建一个新的网站（本地） hugo new site quickstart \u0026amp;\u0026amp; cd quickstart # 拉取stack主题 git init git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 将实例网站拷贝到博客根目录下 cp -r themes/hugo-theme-stack/exampleSite/* ./ # 删除config.toml以防冲突，之后配置文件使用config.yaml rm config.toml # 构建静态网站文件，并启动 HTTP 服务 hugo server -D 云开发部署——Github Pages 托管 先新建一个 github 仓库，如果你想使用 xxx.github.io 这个域名，那么项目名称必须和用户名一致。 第一步，来到 blog 目录，然后初始化 git，并推送到远程仓库。 1 2 3 4 5 6 7 8 git init git add . git commit -m \u0026#39;init\u0026#39; git branch -M main git remote add origin https://.....git # 如果认证失败，那么需要配置一下token，用下面的命令配置 git remote set-url origin https://{token}@{github.com/{username}/{repo_name}.git} git push -u origin main 第二步，**添加 gh-pages.yml 文件。** 在 blog 目录，新建一个名称为.github 的文件夹，然后在.github 文件夹下新建一个 workflows 文件夹，然后在 workflows 文件夹下新建一个文件叫 gh-pages.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 name: github pages permissions: contents: write on: push: branches: - main # Set a branch to deploy jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 第三步，把新代码推送到 github。查看 repo 的 actions 查看是否部署完成，等到部署完，到 setting→pages，将branch 修改为 gh-pages， 点击 save。 过一会，你的主页在 github pages 就托管好了。 ","date":"2023-02-13T00:00:00Z","image":"https://fangjionghao1.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-02-13_18-16-10_huee6ca11520b5c85a3054c81fb42c4215_39305_120x120_fill_box_smart1_3.png","permalink":"https://fangjionghao1.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"从零开始搭建个人博客"},{"content":"设计模式概念 简述 设计模式将算法和具体实现的对象分离\n问题描述 设计了一个应用程序，其中有一些不同的类需要做一个行为，去输出一份信息摘要，但是应用程序已经在线上稳定运行，组长不希望你对现有的类破坏，同时质疑往类中添加摘要的必要性。\n问题解决 这时可以为应用程序添加访问者模式 访问者模式将新行为交给访问者，不同的类型对于访问者执行不同的行为，而不是将新行为整合到访问者当中。 个人感觉这有点像装饰器的行为，不同的是这个行为是依赖于外部的一个访问者。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package main import \u0026#34;fmt\u0026#34; // // DiffDiInfo // @author: FJH // @Description: 用于一组稳定的信息通过访问模式输出自己不同维度的信息，这些信息都是通过自身信息整合而来 // type DiffDiInfo interface { Acceptor(dimension Dimension) // 接收入口， 用于不同维度的接收 } type Dimension interface { FirstDimension(*T1) SecondDimension(*T2) } type T1 struct { info int } func (t *T1) Acceptor(dimension Dimension) { dimension.FirstDimension(t) } type DimensionHandler struct { data interface{} } func (d *DimensionHandler) FirstDimension(t1 *T1) { d.data = t1.info } func (d *DimensionHandler) SecondDimension(t2 *T2) { d.data = t2.info } type T2 struct { info string } func (t *T2) Acceptor(dimension Dimension) { dimension.SecondDimension(t) } type Manager struct { t1 T1 t2 T2 } func main() { manager := Manager{ t1: T1{1}, t2: T2{\u0026#34;2\u0026#34;}, } handler := DimensionHandler{} manager.t2.Acceptor(\u0026amp;handler) fmt.Println(handler.data) } 如果想要更极端的访问者，可以直接使用实例充当访问者，只不过耦合度就高了很多，顺着这个想法下去他就是在这个类型上开了个口子写了装饰器。所以耦合程度从高到低是 装饰\u0026gt;填充实例\u0026gt;访问者\n","date":"2023-02-13T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E7%AE%97%E6%B3%95/","title":"设计模式小试（一）"},{"content":"问题背景 写测试的时候需要 mock 请求，发现整个流程相当复杂\n读文件 拷贝到 multiform.Writer 用 writer 写 filed parse 到 multiform 从 http.Request 当中取出 multiform ","date":"0001-01-01T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/","title":""}]