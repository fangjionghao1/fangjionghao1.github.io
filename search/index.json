[{"content":"背景 在开发 http 服务的时候日常要修修补补，免不了要暂停线上的服务然后发通告更新服务，之后进行非常紧张的更新部署，并在小范围用特殊账号测试做个基本的线上回归。 加入部署出现问题，这时候就要继续发通告延期，久了更新维护更紧张。 为了解决维护的麻烦，选择使用热部署的方式。这样就可以让用户透明的访问，而后台也能正常进行维护。\n##概述\n###什么是热部署\n就是在应用正在运行的时候升级软件，却不需要重新启动应用。 但是对于不同类型的语言来说，热部署的意义不同。 对于 解释型语言，或许就意味着一次更新代码。因为解释型语言只需要从内存中获取相关文件，所以很经常前端代码不需要暂停服务直接替换文件就可以使用。 而对于 编译型语言 基本上就意味着两个不同的可执行文件 基于这两个基本观点，解释型语言和编译型语言的热部署方案就截然不同。\n比如常用的服务器开发语言，java,常见的热部署方案参考 tomcat，devtool 的热重启，\n因为要编译然后跑在 jvm 上，直接简单点认定成编译型语言吧，关于这个点不是今天讨论的重点。有感兴趣的朋友可以在评论区讨论。 今天不讨论解释型语言的热部署方式没因为根本没这个概念，像 php 的热部署就是换一个文件，每次脚本都是去读文件根本不存在之前和之后的区别。\n拿 devtool 来讲，他的做法是分别加载修改的类和不修改的类，再往下是监听文件，实现毫秒级的编译重启。这种做法描述起来就是，我确实断线过，但是太短了（毫秒）察觉不到，用热重启的方式来实现热部署。tomcat 的思路也是差不多就不在赘述。\n另一个热部署的方式就是热替换。 热替换的思路很多，\n游戏服务器的思路是把业务 package 编译成 plugin，动态加载和替换，再通过 plugin.Lookup 来查找和替换函数。 缺点是： 受 Go Plugin 本身的限制，如第三方依赖需要一致、不能引用插件 package、插件内数据类型共享、插件无法释放、调试相对困难、跨平台问题等 对业务代码侵入式较强，包括 plugin main package 限制、Lookup 调用方式、发布流程等 我的做法是代理交接服务。简单来说就是编译了两个服务，我先让两个服务并存，再让流量转到新的服务上从而接管过去的服务。听起来很像代理，所以我个人的做法是用代理的方式。 ##目前最优的解决方案\n使用代理服务，当用户访问的时候实际上是访问代理服务，代理服务为服务器转发流量到当前最新的服务器。 服务器遵守规则： 实现注册服务,服务启动时向代理服务注册自身信息，包括但不仅限于版本号 实现保活服务，代理服务将会访问服务器的保活接口，确保服务器的存活状态。 服务要求识别特殊的返回结构，这是约定好的通信格式，包括一些特定的 code，为了避免污染 proxy 的纯粹性，尽量不要让这种通信格式里面带有一些业务的东西，包括 token 也尽量不要再 proxy 里面有接口。这样的约定一定是基于服务的抽象，比如通知服务中断，服务重启，服务关闭之类的，就目前而言只需要有一个服务重启的信号和一个服务关闭信号就好，而和业务产生关系的只有服务重启。 对于上述的规则做个总结就是，服务器需要一个保活服务、接收服务重启通知的服务和 rpc 的关闭，具体实现的方式其实因人而异，可以选择 http 的就是写一个接口，或者一个 grpc 服务热部署的难点： 本身服务热重启其实做到代理以后完成了一大半。因为服务器内部并不会共享一些资源，包括配置和内存都是独立分配和独立使用。一个未完成的接口调用也由原先的协程来完成，完成后这个协程就再也无法接收到代理信息也就自然可以用机制想办法关闭，proxy 再自然回收那部分内存。问题就在于一个页面往往不仅仅只包含着一个接口调用。 还有要明确的一点就是，服务热部署对于编译型语言编写的服务器，文件层次上一定是两个文件，显而易见他们是不同的执行文件，这也意味着内部端口在热部署的时候至少是占有复数个的 试想这么一种情况，假如说我在加载一个界面的时候进行了热部署，这个时候加载了两种条目，分别来自v1 和 v2 程序就被撕裂了。 如果是 tcp 的服务其实可以考虑，当新的代理连接接入时根据标记判断当前连接的使用状态在完成业务也就是和客户端断开连接的时候主动断开与代理的连接，重新建立连接————长连接总是可以在连接状态上做文章。 http 的想法就不那么自然一点。新的服务被拉起的时候，如果只有一个服务，也就是服务被拉起之前没有任何服务自然是最简单的情况，不需要任何操作直接接受代理服务器的服务就好了。\n而另一种情况就没这么愉快。服务被拉起的时候新旧服务要短暂的并行一段时间，之所以没有直接关闭是可能有正在走旧连接的业务，直接关闭会让一部分请求突然丢失。对应着 tcp 的情况就是检查连接上是否有正在运行的业务。而做这个检查的方式就是在代理服务器记录请求的时间。再具体下去选择的数据结构来承载这个行为，选择的是 map\n可以永远相信带读写锁的 map 来实现业务，而需要更快的检索速度的时候再考虑是否换其他更高效的结构，以及更换结构带来的问题，使用结构带来的复杂度\n用 map 记录服务请求的时间戳超过 300s 没有进行请求的时候可以安心把服务切断切换，转而使用新的连接。使用新连接之后要做相应的扫尾工作，包括删除代理中的注册信息，删除时间戳。同时标记好下一次保活心跳来的时候给应答一个服务重启信号，这个是说给旧服务听的，旧服务再说给外部服务。让外部服务来做一次大更新，包括刷新 token 和个人信息。proxy 做完这些要做一次关闭服务的调用，正式告别旧服务，意味着更新完成。\n本篇主要是方法论，具体实现会在后续更新。\n","date":"2023-02-20T00:00:00Z","image":"https://fangjionghao1.github.io/p/funjohnhow/_hu43d2d81e576066052a6f5913b37b6310_577754_121c9ab0b3dadf7b4b19129b45439ea9.png","permalink":"https://fangjionghao1.github.io/p/funjohnhow/","title":"热部署方案小记"},{"content":"背景 有次朋友跟我聊起恐怖电影，自诩电影爱好者聊起这个领域的东西的时候张口啊闭口嗯，半天支吾不出个所以然来，所以在个人博客开了这个分类，想要整理一些平常感兴趣的领域的概念。\n分类说明 语料表示聊天需要用到的概念或者想法，提前写在博客里面。 电影这个分类就很明朗了，不再说明\n正文 概念 说明 麦格芬（MacGuffin）手法 ——基本释义——① 指某个推动戏剧发展的契机、情节，或角色们拼命追逐的可能不存在的东西，观众也可能不关心，它出现目的在于引导观众沉浸于电影体验 ② 开端是[三十九级台阶]，通过阿尔弗雷德·希区柯克在其后来电影中的使用流行起来。* 举例：“你在做什么？”“我在找麦格芬”“麦格芬是什么”“捕猎北方冰原上狮子的最好武器”“可是北方冰原没有狮子”“那也没有麦格芬” 。麦格芬，按照希区柯克的定义是“悬疑电影中角色们必须要拼命追逐，可观众却可以毫不关心的东西”。但是，在本片中，当要叙述的故事，写实到必须要把破坏份子的意图和目标交代清楚的时候，麦格芬失效了。失效的最直接的后果，就是观众对故事真实性要求大大提高了。因为他们知道了角色动机和事件的来龙去脉，他们也就知道了，相对应的合理逻辑行为关系应该是什么。而这对悬疑片导演来说，是十分可怕的。因为你的剧情设计任何逻辑上的缺陷都很容易就被放大！比如在本片中，当观众了解到破坏份子的政治立场和凶残本性之后，那么影片后半段，男主角只是被打昏，却没有被杀死这个情节就变得难以令人信服。相反，在一个高度风格化、喜剧轻松，且麦格芬有效的故事背景下（比如西北偏北），这些问题就很可能不成为问题。因为观众不清楚，也根本不关注坏人们的行为逻辑。 炸弹理论 如果有三个人在玩儿扑克牌，在牌桌下有一颗炸弹。如果你只是讲述三个人玩牌，然后突然爆炸了，那么故事就毫无悬念。但如果你事先将炸弹的存在告诉读者，然后再展示三个不知情的人玩儿牌，那么观众就会时时刻刻关心炸弹什么时候爆炸。这就是炸弹理论。简单来说，这里理论就是讲，需要在故事开始前，向观众展示一个危机，观众知道，但剧情中的人物并不知道。而这个危机似乎随时都可能爆发。这样，便形成了一个悬念和故事张力。这里的炸弹可以使非常抽象的东西，隐秘的关系，不稳定的因素，脆弱的感情，任何对于观众而言已知的不稳定的因素都可以是炸弹 叙诡（叙述性诡计） 是流行于推理小说写作的一种写作手法。通过运用语言上的歧义，或者偷换文字结构的方式，以达到误导读者的目的。 ","date":"2023-02-20T00:00:00Z","image":"https://fangjionghao1.github.io/p/%E8%AF%AD%E6%96%99%E6%95%B4%E7%90%86/2_hue29632e6cc72d9fc68bcf057123f6a80_4122094_120x120_fill_q75_box_smart1.jpg","permalink":"https://fangjionghao1.github.io/p/%E8%AF%AD%E6%96%99%E6%95%B4%E7%90%86/","title":"语料整理"},{"content":"环境准备 系统环境：Windows 10 专业版\n需求环境：git,hugo,go(1.16 or ⬆),scoop(window 包管理器 不熟悉的同学可以理解成和 npm 差不多的东西)\nhugo 安装文档\nscoop 安装教程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 安装 Hugo brew install hugo(mac 👍) scoop install hugo(win 👍) # 创建一个新的网站（本地） hugo new site quickstart \u0026amp;\u0026amp; cd quickstart # 拉取stack主题 git init git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 将实例网站拷贝到博客根目录下 cp -r themes/hugo-theme-stack/exampleSite/* ./ # 删除config.toml以防冲突，之后配置文件使用config.yaml rm config.toml # 构建静态网站文件，并启动 HTTP 服务 hugo server -D 云开发部署——Github Pages 托管 先新建一个 github 仓库，如果你想使用 xxx.github.io 这个域名，那么项目名称必须和用户名一致。 第一步，来到 blog 目录，然后初始化 git，并推送到远程仓库。 1 2 3 4 5 6 7 8 git init git add . git commit -m \u0026#39;init\u0026#39; git branch -M main git remote add origin https://.....git # 如果认证失败，那么需要配置一下token，用下面的命令配置 git remote set-url origin https://{token}@{github.com/{username}/{repo_name}.git} git push -u origin main 第二步，**添加 gh-pages.yml 文件。** 在 blog 目录，新建一个名称为.github 的文件夹，然后在.github 文件夹下新建一个 workflows 文件夹，然后在 workflows 文件夹下新建一个文件叫 gh-pages.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 name: github pages permissions: contents: write on: push: branches: - main # Set a branch to deploy jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 第三步，把新代码推送到 github。查看 repo 的 actions 查看是否部署完成，等到部署完，到 setting→pages，将branch 修改为 gh-pages， 点击 save。 过一会，你的主页在 github pages 就托管好了。 ","date":"2023-02-13T00:00:00Z","image":"https://fangjionghao1.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-02-13_18-16-10_huee6ca11520b5c85a3054c81fb42c4215_39305_120x120_fill_box_smart1_3.png","permalink":"https://fangjionghao1.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"从零开始搭建个人博客"},{"content":"设计模式概念 简述 设计模式将算法和具体实现的对象分离\n问题描述 设计了一个应用程序，其中有一些不同的类需要做一个行为，去输出一份信息摘要，但是应用程序已经在线上稳定运行，组长不希望你对现有的类破坏，同时质疑往类中添加摘要的必要性。\n问题解决 这时可以为应用程序添加访问者模式 访问者模式将新行为交给访问者，不同的类型对于访问者执行不同的行为，而不是将新行为整合到访问者当中。 个人感觉这有点像装饰器的行为，不同的是这个行为是依赖于外部的一个访问者。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package main import \u0026#34;fmt\u0026#34; // // DiffDiInfo // @author: FJH // @Description: 用于一组稳定的信息通过访问模式输出自己不同维度的信息，这些信息都是通过自身信息整合而来 // type DiffDiInfo interface { Acceptor(dimension Dimension) // 接收入口， 用于不同维度的接收 } type Dimension interface { FirstDimension(*T1) SecondDimension(*T2) } type T1 struct { info int } func (t *T1) Acceptor(dimension Dimension) { dimension.FirstDimension(t) } type DimensionHandler struct { data interface{} } func (d *DimensionHandler) FirstDimension(t1 *T1) { d.data = t1.info } func (d *DimensionHandler) SecondDimension(t2 *T2) { d.data = t2.info } type T2 struct { info string } func (t *T2) Acceptor(dimension Dimension) { dimension.SecondDimension(t) } type Manager struct { t1 T1 t2 T2 } func main() { manager := Manager{ t1: T1{1}, t2: T2{\u0026#34;2\u0026#34;}, } handler := DimensionHandler{} manager.t2.Acceptor(\u0026amp;handler) fmt.Println(handler.data) } 如果想要更极端的访问者，可以直接使用实例充当访问者，只不过耦合度就高了很多，顺着这个想法下去他就是在这个类型上开了个口子写了装饰器。所以耦合程度从高到低是 装饰\u0026gt;填充实例\u0026gt;访问者\n","date":"2023-02-13T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E7%AE%97%E6%B3%95/","title":"设计模式小试（一）"}]