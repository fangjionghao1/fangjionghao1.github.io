[{"content":"背景 从表格导入一些用户数据 顺手开发了这些工具。 本文的前提是了解了基本函数的使用方法，因为有中文文档就不再赘述 excelize 文档地址\n适用场景 任何二维表格都可以用这种方式做统计\n思路简述 找到一个表格的边界，在表格范围内的内容遍历并根据参数按行列进行读取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 var rwM sync.RWMutex // 读写锁 var chMap = map[string]int{ \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2, \u0026#34;C\u0026#34;: 3, \u0026#34;D\u0026#34;: 4, \u0026#34;E\u0026#34;: 5, \u0026#34;F\u0026#34;: 6, \u0026#34;G\u0026#34;: 7, \u0026#34;H\u0026#34;: 8, \u0026#34;I\u0026#34;: 9, \u0026#34;J\u0026#34;: 10, \u0026#34;K\u0026#34;: 11, \u0026#34;L\u0026#34;: 12, \u0026#34;M\u0026#34;: 13, \u0026#34;N\u0026#34;: 14, \u0026#34;O\u0026#34;: 15, \u0026#34;P\u0026#34;: 16, \u0026#34;Q\u0026#34;: 17, \u0026#34;R\u0026#34;: 18, \u0026#34;S\u0026#34;: 19, \u0026#34;T\u0026#34;: 20, \u0026#34;U\u0026#34;: 21, \u0026#34;V\u0026#34;: 22, \u0026#34;W\u0026#34;: 23, \u0026#34;X\u0026#34;: 24, \u0026#34;Y\u0026#34;: 25, \u0026#34;Z\u0026#34;: 26, }// 枚举 var chArr = charArr{ \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;H\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;J\u0026#34;, \u0026#34;K\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;N\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;P\u0026#34;, \u0026#34;Q\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;T\u0026#34;, \u0026#34;U\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;W\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;Z\u0026#34;, } func (c *charArr) Translate(str string) Point { strRunes := []rune(str) colArr := make([]rune, 0) rowArr := make([]rune, 0) for _, strRune := range strRunes { switch strRune \u0026gt; 64 { case false: rowArr = append(rowArr, strRune) case true: colArr = append(colArr, strRune) } } var col int // 为了方便限制在26*26*26 switch len(colArr) { case 3: col = chMap[string(colArr[0])]*26*26 + chMap[string(colArr[1])]*26 + chMap[string(colArr[2])] case 2: col = chMap[string(colArr[0])]*26 + chMap[string(colArr[1])] case 1: col = chMap[string(colArr[0])] } var rowStr string for _, r := range rowArr { rowStr += string(r) } atoi, err := strconv.Atoi(rowStr) if err != nil { return Point{} } return Point{Col: col, Row: atoi} } type Point struct { Row int Col int } func (p *Point) NextCol() { p.Col += 1 } func (p *Point) NextRow() { p.Row += 1 } func (p *Point) trans() string { return chArr.GetAxis(*p) } func GetPoint(s string) Point { return chArr.Translate(s) } type ReadWay int const ( Col = ReadWay(1) // 按列聚合 Row = ReadWay(2) // 按行聚合 ) type ReadParam struct { Point Point Way ReadWay FileName string Sheet string EndPoint Point } func OpenFile(fileName string) (*excelize.File, error) { file, err := excelize.OpenFile(fileName) if err != nil { logger.Log.Errorf(\u0026#34;open excel file error %v\u0026#34;, err) return nil, err } return file, err } // ReadListFromPoint /* 【Description】: 从一个点出发 在end point 之间的表格做出统计 */ func ReadListFromPoint(p ReadParam) (map[string][]string, error) { file, err := OpenFile(p.FileName) if err != nil { return nil, err } defer func() { file.Close() }() m := make(map[string][]string) switch p.Way { case Col: // 按列聚合 startCol := p.Point.Col for p.Point.Row \u0026lt; p.EndPoint.Row { p.Point.NextRow() trans := p.Point.trans() idx, err := file.GetCellValue(p.Sheet, trans) if err != nil { return nil, err } for p.Point.Col \u0026lt; p.EndPoint.Col { p.Point.NextCol() val, _ := file.GetCellValue(p.Sheet, p.Point.trans()) m[idx] = append(m[idx], val) } p.Point.Col = startCol } case Row: // 按行聚合 startRow := p.Point.Row for p.Point.Col \u0026lt; p.EndPoint.Col { p.Point.NextCol() trans := p.Point.trans() idx, err := file.GetCellValue(p.Sheet, trans) if err != nil { return nil, err } for p.Point.Row \u0026lt; p.EndPoint.Row { p.Point.NextRow() val, _ := file.GetCellValue(p.Sheet, p.Point.trans()) m[idx] = append(m[idx], val) } p.Point.Row = startRow } } return m, nil } 比较坑的地方是用官方的按行读取读行标题的时候会导致之前读取的数据被回收，也就是 map 中的数据被清空。 建议是深度拷贝再进行按行列读取\n","date":"2023-02-24T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E5%B7%A5%E5%85%B7/","title":"excelize 库简介"},{"content":"连载中。。。欢迎补充 GO 篇 go 是强类型的语言，这意味着，变量要被指定，基本类型变量一诞生就带上类型，带上类型意味着占有空间，很自然能想到，基本类型的空值是默认有值的，比如 int 的空为 0 ，string 为\u0026quot;\u0026quot;。所以在序列化的时候这部分内容如果想要一个 null 值需要给结构定义指针。 实现接口的时候如果是指针接收者，特别是实现工具自带的接口，比如 marshal，要使用引用。 json 序列化的时候要声明一个临时类型，否则会因为自身的反复调用而 stack overflow 1 2 3 4 5 6 7 8 9 10 func (g *Group) MarshalJSON() ([]byte, error) { type tmp Group return json.Marshal(\u0026amp;struct { *tmp CreateTimeStr string `json:\u0026#34;create_time\u0026#34;` }{ tmp: (*tmp)(g), CreateTimeStr: g.CreatTime.Format(consts.TLayout.Date), }) } go 的时间类型默认格式是 YYYY-MM-DDTHH:MM:SSZ+0800,零时间是 0001-01-01 00：00 +0000 我的做法是日期为 1 的时候判空，不能直接使用。 time 类型直接 string() 接口转出时间的时候，年月日都是单位的比如 3 月就是输出 3，但是一般要转回时间的时候就需要转换成 03,我的做法是静态的对应表，放在 util 里面需要的时候再用。 http 篇 前端数据不可信，不做修改的时候以后端数据为准，唯一值得参考的就是提供的身份信息，包括但不仅限于 id,token。做修改时以前端数据为准。 由于前后端要交换数据，其实选择 string 作为交换的格式挺有风险。举个例子就是时间选用 string 类型的时候后果是每次交互两边都要进行 Fiber 篇 fiber 注册的 handler 是有前后顺序分别的。原因是他在给 app 设置 handler 的时候底层实现是一个 slice。前后调用有区别就意味着不管是路由谁捕捉到，还是过滤器的先后都是有关系的。 staic 提供了很好的静态资源服务，但是要对静态资源做一些处理就很麻烦。我的做法是在 config next 字段加入一些回调能过抓得到 ctx 传下来的 token。对于一些用户相关的资源可以这么做但是不建议。 中间件文件系统暂时没看懂是怎么用的 gorm 篇 综述：gorm 的坑还是非常多的，一不小心就会用错，如果现在开放出来的函数不能实现需求的话建议还是用raw()\n查询篇 where()方法和 or 方法一起使用的时候，以 or 为分界拼接 sql。简单来说就是 or 之后是一个新的子句。 first 方法在查找不到记录的时候会返回一个 notfound 错误，需要做处理，但是 find 不会。 创建篇 在给类型写 scanner valuer 接口的时候 valuer 的接收者不能是指针接收者，否则无法触发相关行为 声明篇 默认的表名，字段名是驼峰改蛇形 model 单数会自动加复数 s table 不会触发 hook 在 gorm.DB 的 model 是使用的时候设置的，如果还想给 hook 传递信息只有通过 set，但是考虑到并发的时候，并不建议给单例 set，可以 getinstance 做一次克隆在给 db set 一些参考的参数。而且 get 需要通过制定的关键字获取，这就意味着要对参数做约定。业务一多，约定的关键字就成了关键字表，不统一管理前后不对照会 panic viper（配置篇） moby 篇（docker） reexec 篇 moby 下一个很方便的工具包，基本上是零以来，可以直接拷贝下来使用。 moby 的基本原理有时间再研究，讲一下注意点。 他会在 arg[0]里设置任务的 pid 让主程序作为子程序的守护，并管理子程序的生命周期。如果想要做守护就是拿着 run()返回的 pid 去反复重启任务。\n源码阅读 cmd_windows.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package reexec // import \u0026#34;github.com/docker/docker/pkg/reexec\u0026#34; import ( \u0026#34;os/exec\u0026#34; ) // Self returns the path to the current process\u0026#39;s binary. // Uses os.Args[0]. func Self() string { return naiveSelf() } // Command returns *exec.Cmd which has Path as current binary. // For example if current binary is \u0026#34;docker.exe\u0026#34; at \u0026#34;C:\\\u0026#34;, then cmd.Path will // be set to \u0026#34;C:\\docker.exe\u0026#34;. func Command(args ...string) *exec.Cmd { return \u0026amp;exec.Cmd{ Path: Self(), Args: args, } } reexec.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func naiveSelf() string { name := os.Args[0] if filepath.Base(name) == name { if lp, err := exec.LookPath(name); err == nil { return lp } } // handle conversion of relative paths to absolute if absName, err := filepath.Abs(name); err == nil { return absName } // if we couldn\u0026#39;t get absolute name, return original // (NOTE: Go only errors on Abs() if os.Getwd fails) return name } ","date":"2023-02-24T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/","title":"web服务踩的坑"},{"content":"背景 系统中有一些定时任务。部署环境windows2003r,所以不能使用 linux 的 crontab 来做定时任务，另外就是编译成一个一个小工具，每次有新的定时任务就要做一个新的小工具。而且代码全封装，像是一个个 dll,如果有问题不好调试。 为此考虑制作一个定时任务调度的小系统。\n思路 需要做的功能从底下到上层分别有 计时器:轮询计时任务列表，不断尝试拿出队头元素，检查是否到了 firetime，如果到了 firetime 执行相应的函数。 计时器离线功能：假如计时器始终在内存中，基本库都能实现这些功能。但是如果系统异常断电还要继续拉起未完成的定时任务，这时候就要考虑两个方向，一个是断线期间过期的任务怎么办，一个是怎么找到之前内存中的计时器。 所以要做持久。 持久的基本思路是：把计时器相关的内容放进数据库（入磁盘-可以不是数据库，文件一样可行）。计时器的相关内容包括，下一个执行时间和执行的函数，由于回调在内存中每次重启函数的内存位置都不好找所以换个思路就是用回调关键字来注册。熟悉微服务的朋友也许就感觉，这不是有点 etcd 的味道了。这样一来每次重启都能恢复计时器。 进一步既然要有回调函数，就要对回调函数进行管理 回调函数管理：包括回调的启停和注册注销 计时器的管理：单纯顺着的计时器并不好用，所以要加上\n找到上一个执行周期 找下一个执行周期 所以持久的内容又要加上上一个执行计时器的时间。\n到目前为止 计时器需要记录 关键字，下一个执行时间（或上一个（如果嫌麻烦可以两个都记录））\n连载中。。。 20230301 更新 发现计时器对于数据库有依赖，这样变成了数据库和定时器深度耦合，对于之后扩展定时任务不利，很容易造成循环依赖。 所以选择了一个做法就是内存计时器在计时的时候提供相关数据给关心的组件订阅，这个订阅动作在计时器开始的时候就已经准备好了。 比如数据库关心这部分的数据，就会拿走相应的结构，比如执行的计时器以及计时器的时间\n关于这个设计有一点要提一下，最早是只提供 id 让数据库根据 id 自己玩，后面发现由于计时器的间隔不一样，同时开始的两个计时器最终的 firetime 会相差甚远。于是加上了执行时间，计时器只记录下一个启动时间。 但是这样设计就立刻暴露出两个问题。\n保持这样的设计保证顺序，要加一个 broker 让其他关心的组件多消费。 不同组件关心的数据不同，broker 是否要加上处理的逻辑 关于回调我还是选择了公共的回调池\n风险是：数据竞争，加了锁也有两个回调同时执行的可能。把回调分配出去意味着回收要去定时堆里面找 收益是：方便做回调的管理， ","date":"2023-02-24T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E5%B7%A5%E5%85%B7/","title":"定时器（待整理）"},{"content":"背景 在开发 http 服务的时候日常要修修补补，免不了要暂停线上的服务然后发通告更新服务，之后进行非常紧张的更新部署，并在小范围用特殊账号测试做个基本的线上回归。 加入部署出现问题，这时候就要继续发通告延期，久了更新维护更紧张。 为了解决维护的麻烦，选择使用热部署的方式。这样就可以让用户透明的访问，而后台也能正常进行维护。\n##概述\n###什么是热部署\n就是在应用正在运行的时候升级软件，却不需要重新启动应用。 但是对于不同类型的语言来说，热部署的意义不同。 对于 解释型语言，或许就意味着一次更新代码。因为解释型语言只需要从内存中获取相关文件，所以很经常前端代码不需要暂停服务直接替换文件就可以使用。 而对于 编译型语言 基本上就意味着两个不同的可执行文件 基于这两个基本观点，解释型语言和编译型语言的热部署方案就截然不同。\n比如常用的服务器开发语言，java,常见的热部署方案参考 tomcat，devtool 的热重启，\n因为要编译然后跑在 jvm 上，直接简单点认定成编译型语言吧，关于这个点不是今天讨论的重点。有感兴趣的朋友可以在评论区讨论。 今天不讨论解释型语言的热部署方式没因为根本没这个概念，像 php 的热部署就是换一个文件，每次脚本都是去读文件根本不存在之前和之后的区别。\n拿 devtool 来讲，他的做法是分别加载修改的类和不修改的类，再往下是监听文件，实现毫秒级的编译重启。这种做法描述起来就是，我确实断线过，但是太短了（毫秒）察觉不到，用热重启的方式来实现热部署。tomcat 的思路也是差不多就不在赘述。\n另一个热部署的方式就是热替换。 热替换的思路很多，\n游戏服务器的思路是把业务 package 编译成 plugin，动态加载和替换，再通过 plugin.Lookup 来查找和替换函数。 缺点是： 受 Go Plugin 本身的限制，如第三方依赖需要一致、不能引用插件 package、插件内数据类型共享、插件无法释放、调试相对困难、跨平台问题等 对业务代码侵入式较强，包括 plugin main package 限制、Lookup 调用方式、发布流程等 我的做法是代理交接服务。简单来说就是编译了两个服务，我先让两个服务并存，再让流量转到新的服务上从而接管过去的服务。听起来很像代理，所以我个人的做法是用代理的方式。 ##目前最优的解决方案\n使用代理服务，当用户访问的时候实际上是访问代理服务，代理服务为服务器转发流量到当前最新的服务器。 服务器遵守规则： 实现注册服务,服务启动时向代理服务注册自身信息，包括但不仅限于版本号 实现保活服务，代理服务将会访问服务器的保活接口，确保服务器的存活状态。 服务要求识别特殊的返回结构，这是约定好的通信格式，包括一些特定的 code，为了避免污染 proxy 的纯粹性，尽量不要让这种通信格式里面带有一些业务的东西，包括 token 也尽量不要再 proxy 里面有接口。这样的约定一定是基于服务的抽象，比如通知服务中断，服务重启，服务关闭之类的，就目前而言只需要有一个服务重启的信号和一个服务关闭信号就好，而和业务产生关系的只有服务重启。 对于上述的规则做个总结就是，服务器需要一个保活服务、接收服务重启通知的服务和 rpc 的关闭，具体实现的方式其实因人而异，可以选择 http 的就是写一个接口，或者一个 grpc 服务热部署的难点： 本身服务热重启其实做到代理以后完成了一大半。因为服务器内部并不会共享一些资源，包括配置和内存都是独立分配和独立使用。一个未完成的接口调用也由原先的协程来完成，完成后这个协程就再也无法接收到代理信息也就自然可以用机制想办法关闭，proxy 再自然回收那部分内存。问题就在于一个页面往往不仅仅只包含着一个接口调用。 还有要明确的一点就是，服务热部署对于编译型语言编写的服务器，文件层次上一定是两个文件，显而易见他们是不同的执行文件，这也意味着内部端口在热部署的时候至少是占有复数个的 试想这么一种情况，假如说我在加载一个界面的时候进行了热部署，这个时候加载了两种条目，分别来自v1 和 v2 程序就被撕裂了。 如果是 tcp 的服务其实可以考虑，当新的代理连接接入时根据标记判断当前连接的使用状态在完成业务也就是和客户端断开连接的时候主动断开与代理的连接，重新建立连接————长连接总是可以在连接状态上做文章。 http 的想法就不那么自然一点。新的服务被拉起的时候，如果只有一个服务，也就是服务被拉起之前没有任何服务自然是最简单的情况，不需要任何操作直接接受代理服务器的服务就好了。\n而另一种情况就没这么愉快。服务被拉起的时候新旧服务要短暂的并行一段时间，之所以没有直接关闭是可能有正在走旧连接的业务，直接关闭会让一部分请求突然丢失。对应着 tcp 的情况就是检查连接上是否有正在运行的业务。而做这个检查的方式就是在代理服务器记录请求的时间。再具体下去选择的数据结构来承载这个行为，选择的是 map\n可以永远相信带读写锁的 map 来实现业务，而需要更快的检索速度的时候再考虑是否换其他更高效的结构，以及更换结构带来的问题，使用结构带来的复杂度\n用 map 记录服务请求的时间戳超过 300s 没有进行请求的时候可以安心把服务切断切换，转而使用新的连接。使用新连接之后要做相应的扫尾工作，包括删除代理中的注册信息，删除时间戳。同时标记好下一次保活心跳来的时候给应答一个服务重启信号，这个是说给旧服务听的，旧服务再说给外部服务。让外部服务来做一次大更新，包括刷新 token 和个人信息。proxy 做完这些要做一次关闭服务的调用，正式告别旧服务，意味着更新完成。\n本篇主要是方法论，具体实现会在后续更新。\n","date":"2023-02-20T00:00:00Z","image":"https://fangjionghao1.github.io/p/funjohnhow/_hu43d2d81e576066052a6f5913b37b6310_577754_121c9ab0b3dadf7b4b19129b45439ea9.png","permalink":"https://fangjionghao1.github.io/p/funjohnhow/","title":"热部署方案小记"},{"content":"背景 有次朋友跟我聊起恐怖电影，自诩电影爱好者聊起这个领域的东西的时候张口啊闭口嗯，半天支吾不出个所以然来，所以在个人博客开了这个分类，想要整理一些平常感兴趣的领域的概念。\n分类说明 语料表示聊天需要用到的概念或者想法，提前写在博客里面。 电影这个分类就很明朗了，不再说明\n正文 概念 说明 麦格芬（MacGuffin）手法 ——基本释义——① 指某个推动戏剧发展的契机、情节，或角色们拼命追逐的可能不存在的东西，观众也可能不关心，它出现目的在于引导观众沉浸于电影体验 ② 开端是[三十九级台阶]，通过阿尔弗雷德·希区柯克在其后来电影中的使用流行起来。* 举例：“你在做什么？”“我在找麦格芬”“麦格芬是什么”“捕猎北方冰原上狮子的最好武器”“可是北方冰原没有狮子”“那也没有麦格芬” 。麦格芬，按照希区柯克的定义是“悬疑电影中角色们必须要拼命追逐，可观众却可以毫不关心的东西”。但是，在本片中，当要叙述的故事，写实到必须要把破坏份子的意图和目标交代清楚的时候，麦格芬失效了。失效的最直接的后果，就是观众对故事真实性要求大大提高了。因为他们知道了角色动机和事件的来龙去脉，他们也就知道了，相对应的合理逻辑行为关系应该是什么。而这对悬疑片导演来说，是十分可怕的。因为你的剧情设计任何逻辑上的缺陷都很容易就被放大！比如在本片中，当观众了解到破坏份子的政治立场和凶残本性之后，那么影片后半段，男主角只是被打昏，却没有被杀死这个情节就变得难以令人信服。相反，在一个高度风格化、喜剧轻松，且麦格芬有效的故事背景下（比如西北偏北），这些问题就很可能不成为问题。因为观众不清楚，也根本不关注坏人们的行为逻辑。 炸弹理论 如果有三个人在玩儿扑克牌，在牌桌下有一颗炸弹。如果你只是讲述三个人玩牌，然后突然爆炸了，那么故事就毫无悬念。但如果你事先将炸弹的存在告诉读者，然后再展示三个不知情的人玩儿牌，那么观众就会时时刻刻关心炸弹什么时候爆炸。这就是炸弹理论。简单来说，这里理论就是讲，需要在故事开始前，向观众展示一个危机，观众知道，但剧情中的人物并不知道。而这个危机似乎随时都可能爆发。这样，便形成了一个悬念和故事张力。这里的炸弹可以使非常抽象的东西，隐秘的关系，不稳定的因素，脆弱的感情，任何对于观众而言已知的不稳定的因素都可以是炸弹 叙诡（叙述性诡计） 是流行于推理小说写作的一种写作手法。通过运用语言上的歧义，或者偷换文字结构的方式，以达到误导读者的目的。 ","date":"2023-02-20T00:00:00Z","image":"https://fangjionghao1.github.io/p/%E8%AF%AD%E6%96%99%E6%95%B4%E7%90%86/2_hue29632e6cc72d9fc68bcf057123f6a80_4122094_120x120_fill_q75_box_smart1.jpg","permalink":"https://fangjionghao1.github.io/p/%E8%AF%AD%E6%96%99%E6%95%B4%E7%90%86/","title":"语料整理"},{"content":"环境准备 系统环境：Windows 10 专业版\n需求环境：git,hugo,go(1.16 or ⬆),scoop(window 包管理器 不熟悉的同学可以理解成和 npm 差不多的东西)\nhugo 安装文档\nscoop 安装教程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 安装 Hugo brew install hugo(mac 👍) scoop install hugo(win 👍) # 创建一个新的网站（本地） hugo new site quickstart \u0026amp;\u0026amp; cd quickstart # 拉取stack主题 git init git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 将实例网站拷贝到博客根目录下 cp -r themes/hugo-theme-stack/exampleSite/* ./ # 删除config.toml以防冲突，之后配置文件使用config.yaml rm config.toml # 构建静态网站文件，并启动 HTTP 服务 hugo server -D 云开发部署——Github Pages 托管 先新建一个 github 仓库，如果你想使用 xxx.github.io 这个域名，那么项目名称必须和用户名一致。 第一步，来到 blog 目录，然后初始化 git，并推送到远程仓库。 1 2 3 4 5 6 7 8 git init git add . git commit -m \u0026#39;init\u0026#39; git branch -M main git remote add origin https://.....git # 如果认证失败，那么需要配置一下token，用下面的命令配置 git remote set-url origin https://{token}@{github.com/{username}/{repo_name}.git} git push -u origin main 第二步，**添加 gh-pages.yml 文件。** 在 blog 目录，新建一个名称为.github 的文件夹，然后在.github 文件夹下新建一个 workflows 文件夹，然后在 workflows 文件夹下新建一个文件叫 gh-pages.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 name: github pages permissions: contents: write on: push: branches: - main # Set a branch to deploy jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 第三步，把新代码推送到 github。查看 repo 的 actions 查看是否部署完成，等到部署完，到 setting→pages，将branch 修改为 gh-pages， 点击 save。 过一会，你的主页在 github pages 就托管好了。 ","date":"2023-02-13T00:00:00Z","image":"https://fangjionghao1.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-02-13_18-16-10_huee6ca11520b5c85a3054c81fb42c4215_39305_120x120_fill_box_smart1_3.png","permalink":"https://fangjionghao1.github.io/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"从零开始搭建个人博客"},{"content":"设计模式概念 简述 设计模式将算法和具体实现的对象分离\n问题描述 设计了一个应用程序，其中有一些不同的类需要做一个行为，去输出一份信息摘要，但是应用程序已经在线上稳定运行，组长不希望你对现有的类破坏，同时质疑往类中添加摘要的必要性。\n问题解决 这时可以为应用程序添加访问者模式 访问者模式将新行为交给访问者，不同的类型对于访问者执行不同的行为，而不是将新行为整合到访问者当中。 个人感觉这有点像装饰器的行为，不同的是这个行为是依赖于外部的一个访问者。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package main import \u0026#34;fmt\u0026#34; // // DiffDiInfo // @author: FJH // @Description: 用于一组稳定的信息通过访问模式输出自己不同维度的信息，这些信息都是通过自身信息整合而来 // type DiffDiInfo interface { Acceptor(dimension Dimension) // 接收入口， 用于不同维度的接收 } type Dimension interface { FirstDimension(*T1) SecondDimension(*T2) } type T1 struct { info int } func (t *T1) Acceptor(dimension Dimension) { dimension.FirstDimension(t) } type DimensionHandler struct { data interface{} } func (d *DimensionHandler) FirstDimension(t1 *T1) { d.data = t1.info } func (d *DimensionHandler) SecondDimension(t2 *T2) { d.data = t2.info } type T2 struct { info string } func (t *T2) Acceptor(dimension Dimension) { dimension.SecondDimension(t) } type Manager struct { t1 T1 t2 T2 } func main() { manager := Manager{ t1: T1{1}, t2: T2{\u0026#34;2\u0026#34;}, } handler := DimensionHandler{} manager.t2.Acceptor(\u0026amp;handler) fmt.Println(handler.data) } 如果想要更极端的访问者，可以直接使用实例充当访问者，只不过耦合度就高了很多，顺着这个想法下去他就是在这个类型上开了个口子写了装饰器。所以耦合程度从高到低是 装饰\u0026gt;填充实例\u0026gt;访问者\n","date":"2023-02-13T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E7%AE%97%E6%B3%95/","title":"设计模式小试（一）"}]