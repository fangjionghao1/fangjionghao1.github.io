[{"content":"环境准备 系统环境：Windows 10 专业版\n需求环境：git,hugo,go(1.16 or ⬆),scoop(window 包管理器 不熟悉的同学可以理解成和 npm 差不多的东西)\nhugo 安装文档\nscoop 安装教程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 安装 Hugo brew install hugo(mac 👍) scoop install hugo(win 👍) # 创建一个新的网站（本地） hugo new site quickstart \u0026amp;\u0026amp; cd quickstart # 拉取stack主题 git init git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack # 将实例网站拷贝到博客根目录下 cp -r themes/hugo-theme-stack/exampleSite/* ./ # 删除config.toml以防冲突，之后配置文件使用config.yaml rm config.toml # 构建静态网站文件，并启动 HTTP 服务 hugo server -D 云开发部署——Github Pages 托管 先新建一个 github 仓库，如果你想使用 xxx.github.io 这个域名，那么项目名称必须和用户名一致。 第一步，来到 blog 目录，然后初始化 git，并推送到远程仓库。 1 2 3 4 5 6 7 8 git init git add . git commit -m \u0026#39;init\u0026#39; git branch -M main git remote add origin https://.....git # 如果认证失败，那么需要配置一下token，用下面的命令配置 git remote set-url origin https://{token}@{github.com/{username}/{repo_name}.git} git push -u origin main 第二步，**添加 gh-pages.yml 文件。** 在 blog 目录，新建一个名称为.github 的文件夹，然后在.github 文件夹下新建一个 workflows 文件夹，然后在 workflows 文件夹下新建一个文件叫 gh-pages.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 name: github pages permissions: contents: write on: push: branches: - main # Set a branch to deploy jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 第三步，把新代码推送到 github。查看 repo 的 actions 查看是否部署完成，等到部署完，到 setting→pages，将branch 修改为 gh-pages， 点击 save。 过一会，你的主页在 github pages 就托管好了。 ","date":"2023-02-13T00:00:00Z","image":"https://fangjionghao1.github.io/p/test-chinese/Snipaste_2023-02-13_18-16-10_huee6ca11520b5c85a3054c81fb42c4215_39305_120x120_fill_box_smart1_3.png","permalink":"https://fangjionghao1.github.io/p/test-chinese/","title":"从零开始搭建个人博客"},{"content":"设计模式概念 简述 设计模式将算法和具体实现的对象分离\n问题描述 设计了一个应用程序，其中有一些不同的类需要做一个行为，去输出一份信息摘要，但是应用程序已经在线上稳定运行，组长不希望你对现有的类破坏，同时质疑往类中添加摘要的必要性。\n问题解决 这时可以为应用程序添加访问者模式 访问者模式将新行为交给访问者，不同的类型对于访问者执行不同的行为，而不是将新行为整合到访问者当中。 个人感觉这有点像装饰器的行为，不同的是这个行为是依赖于外部的一个访问者。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package main import \u0026#34;fmt\u0026#34; // // DiffDiInfo // @author: FJH // @Description: 用于一组稳定的信息通过访问模式输出自己不同维度的信息，这些信息都是通过自身信息整合而来 // type DiffDiInfo interface { Acceptor(dimension Dimension) // 接收入口， 用于不同维度的接收 } type Dimension interface { FirstDimension(*T1) SecondDimension(*T2) } type T1 struct { info int } func (t *T1) Acceptor(dimension Dimension) { dimension.FirstDimension(t) } type DimensionHandler struct { data interface{} } func (d *DimensionHandler) FirstDimension(t1 *T1) { d.data = t1.info } func (d *DimensionHandler) SecondDimension(t2 *T2) { d.data = t2.info } type T2 struct { info string } func (t *T2) Acceptor(dimension Dimension) { dimension.SecondDimension(t) } type Manager struct { t1 T1 t2 T2 } func main() { manager := Manager{ t1: T1{1}, t2: T2{\u0026#34;2\u0026#34;}, } handler := DimensionHandler{} manager.t2.Acceptor(\u0026amp;handler) fmt.Println(handler.data) } 如果想要更极端的访问者，可以直接使用实例充当访问者，只不过耦合度就高了很多，顺着这个想法下去他就是在这个类型上开了个口子写了装饰器。所以耦合程度从高到低是 装饰\u0026gt;填充实例\u0026gt;访问者\n","date":"2023-02-13T00:00:00Z","permalink":"https://fangjionghao1.github.io/p/%E7%AE%97%E6%B3%95/","title":"设计模式小试（一）"}]